<?php
// $Id$

/**
 * @file
 * Implement an amazon shopping cart with search and remote cart capabilities
 *
 */

define('AS_DEBUG', FALSE); // Turn on to execute debug code
define('AMAZON_STORE_PATH', variable_get('amazon_store_path', 'amazon_store'));
define('AMAZON_STORE_STORE_NAME', variable_get('amazon_store_store_name', "Amazon Store"));

/**
 * Implements hook_init().
 */
function amazon_store_init() {
  $locale = variable_get('amazon_locale', 'US');
  //TODO: We probably don't need to load this in hook_init. Figure out where to do it
  $GLOBALS['amazon_store_search_indexes'] = new SearchIndexes($locale);
}


/**
 * Implements hook_menu().
 */
function amazon_store_menu() {
	$amazon_store_path = variable_get('amazon_store_path', 'Amazon Store');
  $amazon_store_store_name = variable_get('amazon_store_store_name', 'Amazon Store');
	$items[$amazon_store_path] = array(
      'title' => $amazon_store_store_name,
      'page callback' => '_amazon_store_page',
      'access callback' => TRUE,
      'type' => MENU_NORMAL_ITEM,
  );
  $items["$amazon_store_path/clear_cart"] = array(
      'page callback' => 'amazon_store_clear_cart',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
  );
  $items["$amazon_store_path/cart"] = array(
      'page callback' => 'amazon_store_show_cart',
      'access callback' => TRUE,
      'title' => 'Your Amazon Cart',
      'type' => MENU_NORMAL_ITEM,
  );
  $items["$amazon_store_path/item"] = array(
      'page callback' => 'amazon_store_item_detail',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
  );
  $items["$amazon_store_path/clear_cache"] = array(
      'page callback' => 'amazon_store_clear_cache',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
  );

// TODO: Consider making amazon_store a tab on amazon settings
  $items['admin/config/amazon_settings/amazon_store'] = array(
      'title' => t('Amazon Store Settings'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('amazon_store_admin_form'),
      'access arguments' => array('access administration pages'),
      'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}



/**
 * Implements hook_block_info.
 */
function amazon_store_block_info() {
  $blocks['amazon_store_search']['info'] = t('Amazon Store Search');
  $blocks['categories']['info'] = t('Amazon Store Categories');
  return $blocks;
}

/**
 * Implements hook_block_view.
 */
function amazon_store_block_view($delta) {
  $block = array();
  switch ($delta) {
    case 'amazon_store_search':
      $block['subject'] = t("Search");
      $block['content'] = theme('amazon_store_search_block');
      break;
    case 'categories':
      $block['subject'] = t('Search Categories');
      $block['content'] = theme('amazon_store_categories');
      break;
      return $block;
  }
  return $block;
}

/**
 * Implements hook_block_configure.
 */
function amazon_store_block_configure($delta) {
  switch ($delta) {
    case 'amazon_store_search':
      $form = array();
      $form['amazon_store_search_block_keywords_width'] = array(
            '#type' => 'textfield',
            '#title' => t('Width (in characters) of keywords element'),
            '#size' => 5,
            '#default_value' => variable_get('amazon_store_search_block_keywords_width',    15),
          );
      return $form;
    case "categories":
      $form = array();
      $form['amazon_store_categories_block_num_columns'] = array(
            '#type' => 'select',
            '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5)),
            '#title' => t('Number of columns'),
            '#default_value' => variable_get('amazon_store_categories_block_num_columns',    2),
          );
      return $form;

  }
}

/**
 * Implements hook_block_save.
 */
function amazon_store_block_save($delta, $edit) {
  switch ($delta) {
    case 'amazon_store_search':
      variable_set('amazon_store_search_block_keywords_width', $edit['amazon_store_search_block_keywords_width']);
      break;
    case "categories":
      variable_set('amazon_store_categories_block_num_columns', $edit['amazon_store_categories_block_num_columns']);
      break;
  }
  return;
}

/**
 * Implements hook_theme();().
 */
function amazon_store_theme() {
  return array(
    'amazon_store_search_results' => array(
        'variables' => array('results' => NULL),
        'template' => 'amazon_store_search_results',
    ),
    'amazon_store_cart' => array(
      'variables' => array('cart' => NULL,),
      'template' => 'amazon_store_cart'
    ),
    'amazon_store_item_detail' => array(
      'variables' => array('amazon_item' => NULL),
      'template' => 'amazon_store_item_detail',
    ),
    'amazon_store_browsenodes_panel' => array(
      'variables' => array('item' => NULL),
      'template' => 'amazon_store_browsenodes_panel',
    ),
    'amazon_store_similar_items_panel' => array(
      'variables' => array('item' => NULL),
      'template' => 'amazon_store_similar_items_panel',
    ),
    'amazon_store_details_panel' => array(
      'variables' => array('item' => NULL),
      'template' => 'amazon_store_details_panel',
    ),
    'amazon_store_item_reviews_panel' => array(
      'variables' => array('item' => NULL),
      'template' => 'amazon_store_item_reviews_panel',
    ),
    'amazon_store_search_results_manufacturer' => array(
      'variables' => array('manufacturer' => NULL),
      'template' => 'amazon_store_search_results_manufacturer',
    ),
    'amazon_store_search_block' => array(
      'template' => 'amazon_store_search_block',
    ),
    'amazon_store_item_image' => array(
      'variables' => array('amazon_item' => NULL, 'size' => NULL),
      'template' => 'amazon_store_item_image',
    ),
    'amazon_store_item_offers' => array(
      'variables' => array('amazon_item' => NULL),
      'template' => 'amazon_store_item_offers',
    ),
    'amazon_store_categories' => array(
      'template' => 'amazon_store_categories',
    ),
    'amazon_store_link_button' => array(
      'variables' => array('text' => NULL, 'url' => NULL),
    ),

  );
}

/**
 * Implements hook_cron();().
 */
function amazon_store_cron() {
  // Clear data which has expired.
  // Normally data should expire within 24 hours, as that
  // is the Amazon AAWS requirement.
  cache_clear_all(NULL, 'cache_amazon_store');
  cache_clear_all(NULL, 'cache_amazon_store_searches');
}

/**
 * Implements hook_flush_caches();().
 *
 * When global cache clean is done (as from devel module)
 * the cache_amazon_store table will be truncated as well
 */
function amazon_store_flush_caches() {
  return array('cache_amazon_store', 'cache_amazon_store_searches');
}

/**
 * Implements hook_forms().
 *
 * Since we have pages with multiple forms of the same type on the
 * search results page and also on the cart page, we have to
 * tell the system where to find the processing function
 */
function amazon_store_forms($form_id) {
  $args = func_get_args();
  $forms = array();
  if (preg_match('/^amazon_store_addcart_form/', $form_id)) {
    $forms[$form_id] = array(
        'callback' => 'amazon_store_addcart_form',
        'callback arguments' => $args[1],
    );
  }
  if (preg_match('/^_amazon_store_cart_quantity_form/', $form_id)) {
    $forms[$form_id] = array(
      'callback' => '_amazon_store_cart_quantity_form',
      'callback arguments' => $args[1],
    );
  }
  if (preg_match('/^amazon_store_buttonize_link/', $form_id)) {
    $forms[$form_id] = array(
      'callback' => 'amazon_store_buttonize_link',
      'callback arguments' => $args[1],
    );
  }
  return $forms;
}


/**
 * Implement hook_ctools_include_directory().
 *
 * Tell ctools where to find plugins
 */

function amazon_store_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return "ctools_plugins/$plugin";
  }
}


// TODO: Update to ctools.
/**
 * Implements hook_ctools_plugin_api().
 */
function amazon_store_ctools_plugin_api($module, $api) {
  if ($module == 'panels_mini' && $api == 'panels_default') {
    return array('version' => 1);
  }
  if ($module == 'page_manager' && $api == 'pages_default') {
    return array('version' => 1);
  }
}

// Template functions for theming

/**
 * This one overrides the amazon module's theming for amazon_item so that
 * the detail page url is local, using amazon_store instead of linking to amazon.com
 *
 * @param $variables
 * @return unknown_type
 */
function amazon_store_preprocess_amazon_item(&$variables) {
  $variables['detailpageurl'] = url(AMAZON_STORE_PATH . '/item/' . $variables['asin'], array('absolute' => TRUE));
}

function template_preprocess_amazon_store_all(&$variables) {
}

/**
 * Process variables for amazon_store_item_detail.
 */
function amazon_store_preprocess_amazon_store_item_detail(&$variables) {
  $amazon_item = $variables['amazon_item'];
  $variables['asin'] = (string)$amazon_item->ASIN;
  if (!empty($amazon_item->EditorialReviews->EditorialReview[0]->Content)) {
    $variables['editorialreview'] =  _filter_htmlcorrector(filter_xss_admin($amazon_item->EditorialReviews->EditorialReview[0]->Content));
  }

}

function template_preprocess_amazon_store_cart(&$variables) {
  $cart = & $variables['cart'];
  $variables['fullrecords'] = array();
  $fullrecords = & $variables['fullrecords'];
  // Add the full info on the item and the availability of this offer to the
  // cart info
  if (!empty($cart->CartItems)) {
    foreach ($cart->CartItems->CartItem as $item) {
      $fullinfo = amazon_store_retrieve_item($item->ASIN);
      $fullrecords[] = $fullinfo;
      $merchantId = (string) $item->MerchantId;
      $query = "//Offer/Merchant[MerchantId=\"$merchantId\"]/../OfferListing/Availability";
      $availability = $fullinfo->xpath($query);
      if (empty($availability)) { // Might be a seller - try it that way
        $query = "//Offer/Seller[SellerId=\"$merchantId\"]/../OfferListing/Availability";
        $availability = $fullinfo->xpath($query);
      }
      $item->addChild("Availability", (string) $availability[0]);
    }
  }
}

/**
 * Form builder function for the admin settings form.
 */
function amazon_store_admin_form($form, &$form_state) {

  $form['amazon_store_store_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Store name'),
    '#description' => t('The descriptive name of the store to be be shown in the menu, title, etc.'),
    '#size' => 25,
    '#default_value' => variable_get('amazon_store_store_name', 'Amazon Store'),
  );
  $form['amazon_store_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Path to store'),
    '#description' => t('The Drupal path to the store. If you change this, you will have to rebuild the menu cache for it to take effect.'),
    '#size' => 25,
    '#default_value' => variable_get('amazon_store_path', 'amazon_store'),
  );
  $form['amazon_store_show_searchform'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display search form'),
    '#default_value' => variable_get('amazon_store_show_searchform', 1),
  );
  $form['amazon_store_show_narrowby_form'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display "narrow by" form'),
    '#default_value' => variable_get('amazon_store_show_narrowby_form', 1),
  );
  $form['amazon_store_show_sort_form'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display sort form'),
    '#default_value' => variable_get('amazon_store_show_sort_form', 1),
  );
  $form['amazon_store_show_category_select'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display category selection pulldown'),
    '#default_value' => variable_get('amazon_store_show_category_select', 1),
    '#description' => t("Deselect if you want to hide the category selection pulldown.")
  );

  $form['amazon_store_merchant_id'] = array(
    '#type' => 'radios',
    '#title' => t('Default Merchant ID for search'),
    '#default_value' => variable_get('amazon_store_merchant_id', 'All'),
    '#options' => array('Amazon' => 'Amazon', 'All' => 'All'),
    '#description' => t('You may search all sellers on Amazon or just the items that Amazon.com/uk/fr etc sells.'),
  );
  $form['amazon_store_search_index_choice'] = array(
    '#type' => 'select',
    '#title' => t('Default search index selection on amazon_store page'),
    '#description' => t("The default search index on the amazon_store page. If you turn off the category pulldown above, this will be used as the search index."),
    '#options' => $GLOBALS['amazon_store_search_indexes']->getSearchIndexPulldown(FALSE),
    '#default_value' => variable_get('amazon_store_search_index_choice', "Books"),
  );
  $form['amazon_store_default_items'] = array(
    '#type' => 'radios',
    '#title' => t('Default items for amazon_store page if no search has been done (no keywords present)'),
    '#description' => t("You may choose either a simple search index (and its default browsenode), a specific browsenode, or a list of items to display on the default amazon_store page"),
    '#options' => array(
      'searchindex' => t("SearchIndex Only - Use Amazon's default browsenode for the selected search index"),
      'browsenode' => t('A browsenode specified below'),
      'itemlist' => t("A list of Amazon ASINs specified below"),
    ),
    '#default_value' => variable_get('amazon_store_default_items', 'searchindex'),
  );
  $form['amazon_store_default_search_index'] = array(
    '#type' => 'select',
    '#title' => t('Search index used to populate items on page with no keywords'),
    '#description' => t("If you selected 'SearchIndex Only' above, this is the search index that will be used to select items"),
    '#options' => $GLOBALS['amazon_store_search_indexes']->getSearchIndexPulldown(TRUE),
    '#default_value' => variable_get('amazon_store_default_search_index', "Books"),
  );

  $form['amazon_store_default_browsenode_id'] = array(
    '#type' => 'textfield',
    '#title' => t("Default Browsenode ID"),
    '#description' => t("Browsenode ID to use as default search. This browsenode MUST be valid with the Search Index you have chosen. You can find browsenodes at <a href='http://browsenodes.com'>browsenodes.com</a>"),
    '#size' => 12,
    '#default_value' => variable_get('amazon_store_default_browsenode_id', ""),
  );

  $form['amazon_store_default_item_list'] = array(
    '#type' => 'textfield',
    '#title' => t("Default Item List"),
    '#description' => t("Comma-separated list of up to 10 Amazon ASINs that should be displayed by default on the amazon_store page"),
    '#size' => 80,
    '#default_value' => variable_get('amazon_store_default_item_list', ""),
  );

  $period = drupal_map_assoc(array(3600, 7200, 43200, 86400), 'format_interval');
  $form['amazon_store_refresh_schedule'] = array(
    '#type' => 'select',
    '#title' => t('Refresh schedule'),
    '#description' => t("Cached information must be cleared regularly to keep informaton current and to comply with Amazon's requirements. Cron must be enabled for this function to work properly."),
    '#default_value' => variable_get('amazon_store_refresh_schedule', 43200),
    '#options' => $period
  );

  $form['amazon_store_include_categories'] = array(
      '#type' => 'checkboxes',
      '#title' => t("Categories to include in search box, category search block, etc. It's often preferable to exclude some categories"),
      '#description' => t("Note that this list changes if you change the locale, so you will have to revisit this page after changing the locale on the <a href='!amazon_settings_url'>Amazon Module Settings</a> page.", array('!amazon_settings_url' => url('admin/config/amazon_settings/amazon'))),
      '#options' => $GLOBALS['amazon_store_search_indexes']->getAllCategories(),
      '#default_value' => variable_get('amazon_store_include_categories', $GLOBALS['amazon_store_search_indexes']->getRecommendedCategories()),
  );

  $form = system_settings_form($form);
  $form['#submit'][] = 'amazon_store_admin_form_submit';
  return $form;
}

/**
 * Rebuild menu when settings submitted, as they might have changed the menu.
 */
function amazon_store_admin_form_submit($form, &$form_state) {
  menu_rebuild();
}

/**
 * Cache an amazon item - pass in SimpleXML item.
 *
 * Timeout is controlled by the module's admin settings.
 *
 * @param (SimpleXML) $xml
 *   A simplexml item.
 */
function amazon_store_cache_item($xml) {

  $cache_timeout = variable_get('amazon_store_refresh_schedule', 43200);
  $locale = variable_get('amazon_locale', 'US');

  // If you cache the object itself it can't be deserialized. http://drupal.org/node/199337
  // So we cache the XML instead
  cache_set("ASIN-{$xml->ASIN}-{$locale}", $xml->asXML(), 'cache_amazon_store', REQUEST_TIME + $cache_timeout);
}


/**
 * Try to get a product-description XML from the cache.
 * If it's not there, get it from Amazon
 *
 * @param $asin
 * 	Amazon.com ASIN identifier
 * @return
 * 	Item as SimpleXML object
 */
function amazon_store_retrieve_item($asin) {
  $locale = variable_get('amazon_locale', 'US');

  $item = cache_get("ASIN-{$asin}-{$locale}", 'cache_amazon_store');
  if ($item && $item->data) {
    $xml = new SimpleXMLElement($item->data);
  }
  else { // Item was not in cache
    $xml = amazon_store_get_item_data($asin);
  }
  return $xml;
}

/**
 * Cache an amazon search; alphabetize the params and use that
 * as key.
 *
 * @param  $parameters
 *  Parameters as available per Amazon docs
 * @param  $results
 * 	SimpleXML object with the search
 */
function amazon_store_cache_search($parameters, $results) {
  $cache_timeout = variable_get('amazon_store_refresh_schedule', 43200);
  $locale = variable_get('amazon_locale', 'US');

  ksort($parameters);
  $key = "Search-$locale-" . implode('/', array_keys($parameters)) . implode('/', $parameters);
  cache_set($key, $results->asXML(), 'cache_amazon_store_searches', REQUEST_TIME + $cache_timeout);
}

/**
 * Get a cached Amazon search and instantiate as SimpleXML obj
 *
 * @param  $parameters
 * @return
 * 	SimpleXML object or NULL if not found in cache
 */
function amazon_store_retrieve_cached_search($parameters) {
  $locale = variable_get('amazon_locale', 'US');

  $xml = NULL;
  ksort($parameters);
  $key = "Search-$locale-" . implode('/', array_keys($parameters)) . implode('/', $parameters);

  $item = cache_get($key, 'cache_amazon_store_searches');
  if ($item && $item->data) {
    $xml = new SimpleXMLElement($item->data);
  }
  return $xml;
}


function parametersForKeywordSearch($keywords) {
  return array(
  'SearchIndex' => 'All',
  'Keywords' => htmlentities("\"$keywords\""),
  'Operation' => 'ItemSearch',
  );
}


// Main page entry points
/**
 * Primary Amazon Store page, with search form, results, and SearchBins if they are available
 *
 * This page will respond to the various GET parameters and display the resultant search results
 * SearchIndex
 * Keywords
 * MinimumPrice
 * MaximumPrice
 * BrowseNode
 * MerchantId
 * Brand
 * Sort
 * author, composer, manufacturer, artist (not really well implemented at this point)
 *
 * If no keywords are supplied, it goes to the top-level browsenode of the selected SearchIndex
 */
function _amazon_store_page() {

  $output = "";
  $parameters = array();


  // Grab the URL args that we'll allow and put them in as parameters for Amazon search
  extract($_GET, EXTR_PREFIX_ALL, "get");
  if (!empty($get_SearchIndex)) {
    $parameters['SearchIndex'] = check_plain($get_SearchIndex);
  }
  if (!empty($get_Keywords)) {
    $parameters['Keywords'] = preg_replace('/[\'\"]/', '', $get_Keywords);
  }
  if (!empty($get_ItemId)) {
    $parameters['ItemId'] = filter_xss($get_ItemId);
  }
  if (!empty($get_BrowseNode)) {
    $parameters['BrowseNode'] = intval($get_BrowseNode);
  }
  if (!empty($get_MinimumPrice)) {
    $parameters['MinimumPrice'] = intval($get_MinimumPrice);
  }
  if (!empty($get_MaximumPrice)) {
    $parameters['MaximumPrice'] = intval($get_MaximumPrice);
  }
  if (!empty($get_MerchantId)) {
    $parameters['MerchantId'] = check_plain($get_MerchantId);
  }
  if (!empty($get_Brand)) {
    $parameters['Brand'] = filter_xss($get_Brand);
  }
  if (!empty($get_Sort)) {
    $parameters['Sort'] = check_plain($get_Sort);
  }
  if (!empty($get_page)) {
    // Drupal pager is 0-based. Amazon is 1-based. Adjust for that.
    $parameters['ItemPage'] = intval($get_page) + 1;
  }
  else {
    $get_page = 1;
  }

  if (!empty($parameters['SearchIndex']) && $parameters['SearchIndex'] == 'All' && !empty($parameters['BrowseNode'])) {
    $parameters['SearchIndex'] = variable_get('amazon_store_default_search_index', "Books");
  }

  foreach (array('Author', 'Composer', 'Artist', 'Manufacturer') as $entity) {
    $getarg = "get_$entity";
    if (!empty($$getarg) && amazon_store_allowed_parameter($parameters['SearchIndex'], $entity)) {
      $parameters[$entity] = $$getarg;
    }
  }

  // If we have no keywords, browse the SearchIndex.
  if (empty($parameters['Keywords']) && empty($parameters['BrowseNode']) && empty($parameters['ItemId'])) {
    $browseNodes = $GLOBALS['amazon_store_search_indexes']->getBrowseNodes();
    if (empty($parameters['SearchIndex']) || $parameters['SearchIndex'] == 'All') {
      $parameters['SearchIndex'] = variable_get('amazon_store_default_search_index', "Books");
    }
    // If they have configured a browsenode, use that
    $defaultlist = variable_get('amazon_store_default_items', 'searchindex');
    switch ($defaultlist) {
      case 'searchindex': // Use the default browsenode for searchindex
        if (!empty($browseNodes[$parameters['SearchIndex']])) {
          $parameters['BrowseNode'] = $browseNodes[$parameters['SearchIndex']];
        }
        break;
      case 'browsenode':
        $parameters['BrowseNode'] = variable_get('amazon_store_default_browsenode_id', 0);
        break;
      case 'itemlist':
        $parameters['ItemId'] = variable_get('amazon_store_default_item_list', "");
        break;
    }
  }

  if (!empty($parameters['ItemId'])) {
    $results = _amazon_store_itemlist(array('ItemId' => $parameters['ItemId']));
  }
  else {
    $results = _amazon_store_search($parameters );
  }

  $output .= theme('amazon_store_search_results', array('results' => $results));
  return $output;
}


/**
 * Add an item to cart by ASIN (default) or OfferListingId (much better)
 * @param $item_id  The item ID - either an ASIN or and OfferListingId
 * @param $id_type  Type: Either "ASIN" or "OfferListingId"
 * @param $quantity - Number to add
 * @param $norecurse - If TRUE, do not call this again
 * @return TRUE on success
 */
function _amazon_store_add_to_cart($asin,   $offerListingId = NULL, $quantity = 1, $norecurse = FALSE ) {

  amazon_store_get_cart_info($cart_id, $cart_HMAC);
  $parameters = array();
  if (!empty($offerListingId)) {
    $type = "OfferListingId";
    $id = $offerListingId;
    $parameters['OfferListingId'] = $id;

  }
  else {
    $type = 'ASIN';
    $parameters['ASIN'] = $asin;
    $id = $asin;
  }

  // Do CartAdd operation with cart_id
  $parameters += array(
      'MergeCart' => 'True',
      'CartId' => $cart_id,
      'HMAC' => $cart_HMAC,
      "Item.1.$type" => $id,
      'Item.1.Quantity' => $quantity,
  );

  $items = array();
  if ($cart_id) { // If we already have a cart, try this.
    $results = amazon_store_http_request('CartAdd', $parameters);
    if (empty($results->error)) {
      return TRUE;
    }
    if ((string) $results->Cart->Request->Errors->Error->Code == "AWS.ECommerceService.ItemAlreadyInCart") {
      $cart_item_id = $results->Cart->CartItems->CartItem[0]->CartItemId;
      $requested_quantity = (int)$results->Cart->CartItems->CartItem[0]->Quantity;
      amazon_store_update_cart_quantity((string)$cart_item_id, $requested_quantity);
      return TRUE;
    }
    elseif ((string) $results->Cart->Request->Errors->Error->Code == "AWS.ECommerceService.CartInfoMismatch") {
      // Probably the sponsored cause, and thus the associate id, has changed
      // Fall through
      watchdog('amazon', "Failed adding item to cart but will now create new cart - code=%code", array('%code' => (string) $results->Request->Errors->Error->Code));
    }
    else {
      drupal_set_message("Failed adding item to cart");
      watchdog('amazon', "Failed adding item to cart - code=%code", array('%code' => (string) $results->Cart->Request->Errors->Error->Code));
      return FALSE;
    }
  }


  // If CartAdd fails and falls through from above
  //    Do CartCreate with cart_id
  //    Get new cart_id and update user with it
  // In all cases, log resultsresults->
  // In Initial stages, we should probably show the cart after doing an add
  $results = amazon_store_http_request('CartCreate', $parameters);
  if ($results->error) {
    drupal_set_message(t("Failed to create cart"));
    watchdog("amazon", "Failed to create cart");
    return FALSE;
  }
  elseif ($results->Cart->Request->IsValid == 'True') {
    amazon_store_set_cart_info((string) $results->Cart->CartId, (string) $results->Cart->HMAC);
    return TRUE;
  }

  return FALSE;
}


function amazon_store_get_current_cart_quantity($cartItemId) {
  amazon_store_get_cart_info($cart_id, $cart_HMAC);

  $parameters = array(
      'MergeCart' => 'True',
      'CartId' => $cart_id,
      'HMAC' => $cart_HMAC,
      "Item.1.CartItemId" => $cartItemId,
  );
  $results = amazon_store_http_request('CartGet', $parameters);
  $current_quantity = (int) $results->Cart->CartItems->CartItem[0]->Quantity;
  return $current_quantity;
}


/**
 * Update quantity on a cart item
 *
 * @param  $cartItemId
 * 	CartItemId
 * @param  $quantity
 * @param  $item_number
 * @return
 * 	TRUE on success
 */
function amazon_store_update_cart_quantity($cartItemId, $quantity ) {

  amazon_store_get_cart_info($cart_id, $cart_HMAC);

  $parameters = array(
      'MergeCart' => 'True',
      'CartId' => $cart_id,
      'HMAC' => $cart_HMAC,
      "Item.1.CartItemId" => $cartItemId,
      'Item.1.Quantity' => $quantity,
  );

  $results = amazon_store_http_request('CartModify', $parameters);
  foreach ($results->Cart->CartItems->CartItem as $cartitem) {
    if ($cartitem->CartItemId == $cartItemId) {
      $actual_quantity = $quantity > 0 ? (int)$cartitem->Quantity : $quantity;
    }
  }
  if (empty($results->error)) {
    drupal_set_message(t("Cart quantity updated to @quantity", array('@quantity' => $actual_quantity)));
    return TRUE;
  }
  else {
    drupal_set_message(t("Failed to update cart quantity"));
    watchdog('amazon', "Failed to update cart quantity. Errors=%errors", array('%errors' => print_r($results->Cart->Request->Errors, TRUE)));
    return FALSE;
  }
  return FALSE;
}


/**
 * Empty the cart
 *
 */
function amazon_store_clear_cart($form, &$form_state, $destination = "amazon_store") {
  if (!$destination) {
    $destination = AMAZON_STORE_PATH;
  }
  $form = array();
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t("Clear cart")
  );
  $form_state['redirect'] = $destination;
  return $form;
}
function amazon_store_clear_cart_submit($form, &$form_state) {
  amazon_store_get_cart_info($cart_id, $cart_HMAC);

  // Do CartAdd operation with cart_id
  $parameters = array(
      'MergeCart' => 'True',
      'CartId' => $cart_id,
      'HMAC' => $cart_HMAC,
  );
  $items = array();
  if ($cart_id) {
    $results = amazon_store_http_request('CartClear', $parameters);
    if (!empty($results->error)) {
      watchdog('amazon', "Failed to clear shopping cart");
      drupal_set_message(t("failed to clear shopping cart"));
      return;
    }
  }
  drupal_set_message(t("Your shopping cart is now empty"));
}

/**
 * The cart display page
 *
 * @return rendered page contents
 */
function amazon_store_show_cart() {
  // Prevent caching. This one shouldn't be cached.
  $GLOBALS['conf']['cache'] = FALSE;

  amazon_store_get_cart_info($cart_id, $cart_HMAC);

  $parameters = array(
      'CartId' => $cart_id,
      'HMAC' => $cart_HMAC,
      'MergeCart' => 'True',
  );
  $items = array();
  if ($cart_id) {
    $results = amazon_store_http_request('CartGet', $parameters);
    // Check results
    if (!empty($results->error) || $results->Cart->Request->IsValid != 'True') {
      amazon_store_report_error($results->Cart->Request->Errors);
      drupal_set_message(t("Failed to get cart"));
    }
  }
  // Display the cart
  if (!empty($results->Cart)) {
    $result = theme('amazon_store_cart', array('cart' => $results->Cart));
  }
  else {
    $result = t("There is nothing in your cart.");
  }
  return "<div>$result</div>";
}

function amazon_store_item_detail($asin) {
  $item = amazon_store_retrieve_item($asin);
  if (empty($item)) {
    $output = t('Sorry, this is either an invalid URL or this item is no longer available from Amazon');
  }
  else {
    $output = theme('amazon_store_item_detail', array('amazon_item' => $item));
  }
  return $output;
}

// Utility functions   ///////

/**
 * Return the cart ID and HMAC from session variable
 *
 * @param $cart_id
 * @param $cart_HMAC
 */
function amazon_store_get_cart_info(&$cart_id, &$cart_HMAC) {
  $cart_id = empty($_SESSION['cart_id']) ? NULL : $_SESSION['cart_id'];
  $cart_HMAC = empty($_SESSION['HMAC']) ? NULL : $_SESSION['HMAC'];
}

/**
 * Set cart ID and HMAC in session variable
 *
 * @param $cart_id
 * @param $cart_HMAC
 */
// TODO: Isolate amazon info in sessions and name it better
function amazon_store_set_cart_info($cart_id, $cart_HMAC) {
  $_SESSION['cart_id'] = $cart_id;
  $_SESSION['HMAC'] = $cart_HMAC;
}

/**
 * Utility function for reporting errors as reported in the
 * errors portion of SimpleXML Amazon item object.
 *
 * @param $errors
 */
function amazon_store_report_error($errors) {
  foreach ($errors->Error as $error) {
    $i++;
    $msg .= "($i): {$error->Code}: {$error->Message} <br/>";
  }
  watchdog('amazon', 'Error processing SimpleXML: @msg', array('@msg' => $msg));
}

/**
 * Basic Amazon search form.
 */
function amazon_store_search_form($form, &$form_state, $keyword_width = 15) {

  $moduledir = drupal_get_path('module', 'amazon_store');
  $form['#attached']['css'] = array("$moduledir/amazon_store.css");
  $form['#attached']['js'] = array("$moduledir/amazon_store.js");

  if (variable_get('amazon_store_show_category_select', TRUE)) {
    $form['SearchIndex'] = array(
        '#title' => t('Category'),
        '#type' => 'select',
        '#options' => $GLOBALS['amazon_store_search_indexes']->getSearchIndexPulldown(),
        '#default_value' => !empty($_GET['SearchIndex']) ? $_GET['SearchIndex'] : variable_get('amazon_store_search_index_choice', 'All'),
    );
  }
  else {
    $form['SearchIndex'] = array(
      '#type' => 'value',
      '#value' => variable_get('amazon_store_search_index_choice', 'All'),
    );
  }
  $form['Keywords'] = array(
      '#title' => t('Search For'),
      '#type' => 'textfield',
      '#size' => $keyword_width,
      '#default_value' => isset($_GET['Keywords']) ? $_GET['Keywords'] : "",
  );
  $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Search'),
  );
  $form['clear'] = array(
    '#type' => 'markup',
    '#markup' => "<div class='search-form-clear'></div>",
  );
  return $form;

}

function amazon_store_search_form_submit($form, &$form_state) {
  $form_state['redirect'] = array(AMAZON_STORE_PATH, array('query' => array('Keywords' => $form_state['values']['Keywords'], 'SearchIndex' => $form_state['values']['SearchIndex'])));
}

/**
 * Do an xpath search on passed-in SimpleXML object, returning the results
 * This takes care of namespace issues
 *
 * The query does have to have the "a" prefix. Example query:
 *   $errors = amazon_store_xpath($someSimpleXML,'//a:Error');

 *
 * @param  $xml
 * 	SimpleXML object on which to perform search
 * @param  $query
 * 	Xpath query
 * @return results of query as Xpath object
 */
function amazon_store_xpath($xml, $query) {
  // Amazon uses default namespace, so need to fiddle with xpath.
  // Description of this comes from http://us2.php.net/manual/en/function.simplexml-element-xpath.php#87141
  $namespaces = $xml->getNamespaces(true);
  if (isset($namespaces[""])) {
    $xml->registerXPathNamespace("a", $namespaces[""]);
  }
  $result = $xml->xpath($query);
  return $result;
}

/**
 * Wrapper on amazon_http_request.
 * Checks for errors on all requests and logs them.
 *
 * @param $op
 * 	Operation to perform: ItemSearch, CartAdd, etc.
 * @param $parameters
 * 	Array of parameters for the request
 * @return SimpleXML object (or NULL) and  $result->error set if there was an error detecdted
 */
function amazon_store_http_request($op, $parameters) {
  if (AS_DEBUG) {
    drupal_set_message("Request: op=$op, Parameters=" . print_r($parameters, TRUE));
  }
  $results = amazon_http_request($op, $parameters);
  if (empty($results)) {
    watchdog('amazon_store', 'Failed call to amazon_http_request; op=%op, parameters = %parameters', array('%op' => $op, '%parameters' => print_r($parameters, TRUE)));
    drupal_set_message(t("amazon_http_request failed; op=@op, parameters=@parameters.", array('@op' => $op, '@parameters' => print_r($parameters, TRUE))));
    return NULL;
  }

  $errors = amazon_store_xpath($results, '//a:Error');
  foreach ($errors as $error) {
    $msg = "Amazon error returned. Code=$error->Code}, Message={$error->Message} //";
    $error_set = TRUE;
  }

  if (isset($error_set)) {
    $errors = "";
    watchdog('amazon', 'There was an error accessing amazon. Message=@msg, results=@results', array('@msg' => $msg, '@results' => print_r($results, TRUE)));
    $results->error = $msg;
  }
  return ($results);
}

function amazon_store_filter_results($unfiltered_items) {
  $filtered_results = clone $unfiltered_items;
  for ($i = count($unfiltered_items->Item) -1; $i >= 0; $i--) {
    $item = $unfiltered_items->Item[$i];
    // Drop the item if it has no variations and also has no offers.
    if (!count($item->Variations) && ($item->Offers->TotalOffers == 0 || $item->OfferSummary->TotalNew == 0)) {
      unset($filtered_results->Item[$i]);
    }
  }
  return $filtered_results;
}

/**
 * Perform the search on AAWS
 *
 * @param  $parameters
 * 	Array of parameters, as defined by AAWS
 * @return
 * 	SimpleXML result with search results
 */
function _amazon_store_search($parameters = array()) {
  $locale = variable_get('amazon_locale', 'US');
  $response_groups = "Variations,Images,ItemAttributes,OfferFull";
  if ($parameters['SearchIndex'] != 'Apparel') {
    $response_groups .= ',EditorialReview,Similarities,AlternateVersions,Large';
  }
  if ($locale == 'US') { // SearchBins not currently supported outside US
    $response_groups .= ',SearchBins';
  }
  $parameters['ResponseGroup'] = $response_groups;

  if (empty($parameters['MerchantId'])) {
    $parameters['MerchantId'] = variable_get('amazon_store_merchant_id', 'All');
  }
  $parameters['Condition'] = 'New';

  if (! ($filtered_results = amazon_store_retrieve_cached_search($parameters))) {
    $results = amazon_store_http_request('ItemSearch', $parameters);
    if (empty($results->error) && !empty($results->Items->Item)) {
      // Filter results to exclude things that have no offers or variations.
      $filtered_results = amazon_store_filter_results($results->Items);
      amazon_store_cache_search($parameters, $filtered_results);
      foreach ($filtered_results->Item as $item) {
        amazon_store_cache_item($item);
      }
    }
  }

  return $filtered_results;
}

/**
 * Just like search, but takes a comma-separated item list of ASINs instead
 * @param $itemlist
 *   Parameters to pass. Normal would be array('ItemId' => 'asin1,asin2,...')
 * @return unknown_type
 */
function _amazon_store_itemlist($parameters = array()) {
  $parameters['ResponseGroup'] = 'Variations,ItemAttributes,Images,EditorialReview,OfferFull,Reviews,Similarities,AlternateVersions,Large';

  if (! ($results = amazon_store_retrieve_cached_search($parameters))) {
    $results = amazon_store_http_request('ItemLookup', $parameters);
    if (empty($results->error) && !empty($results->Items->Item)) {
      amazon_store_cache_search($parameters, $results);
      foreach ($results->Items->Item as $item) {
        amazon_store_cache_item($item);
      }
    }
  }

  return $results->Items;
}

/**
 * Request info about a single item from amazon
 *
 * @param unknown_type $asin
 * @return unknown
 */
function amazon_store_get_item_data($asin) {
  $parameters = array(
      'ResponseGroup' => 'Variations,Images,ItemAttributes,OfferFull,Large,EditorialReview',
  'ItemId' => $asin,
      'MerchantId' => "All",
  );

  $items = array();
  $results = amazon_store_http_request('ItemLookup', $parameters);
  $amazon_item = $results->Items->Item[0];
  if (!empty($amazon_item)) {
    amazon_store_cache_item($amazon_item);
  }
  return $amazon_item;
}

/**
 * Clear a single cached item from the cache, identified by ASIN
 *
 * @param unknown_type $asin
 */
function amazon_store_clear_cache($asin) {
  if (!empty($asin)) {
    cache_clear_all("ASIN-" . $asin, 'cache_amazon_store');
  }
  drupal_goto();
}

/**
 * Map product group to SearchIndex so we can browse a SearchIndex based on product group
 *
 * @param unknown_type $ProductGroup
 * @return SearchIndex
 * 	Returns the most likely SearchIndex for this productGroup
 */
function ProductGroup2SearchIndex($ProductGroup) {
  /**
   * This array was made by a download of product group to SearchIndex membership
   * on browsenode.com. Then I made arbitrary decisions about the single
   * primary SearchIndex that a ProductGroup would imply, since the mapping
   * was many to many.
   */

  static $map = array(
    "Amazon Devices" => "Electronics",
    "Apparel" => "Apparel",
    "Audible" => "Books",
    "Automotive Parts and Accessories" => "Automotive",
    "Automotive Parts and Accessories" => "Tools",
    "Baby Product" => "Baby",
    "Beauty" => "Beauty",
    "BISS" => "All",
    "Book" => "Books",
    "CE" => "Electronics",
    "Classical" => "Classical",
    "Digital Music Album" => "MP3Downloads",
    "Digital Music Artist" => "MP3Downloads",
    "Digital Music Track" => "MP3Downloads",
    "Digital Text Feeds" => "Books",
    "DVD" => "DVD",
    "eBooks" => "Books",
    "Furniture" => "OfficeProducts",
    "Gourmet" => "GourmetFood",
    "Grocery" => "Grocery",
    "Health and Beauty" => "HealthPersonalCare",
    "Home" => "Tools",
    "Home Improvement" => "HomeGarden",
    "Jewelry" => "Jewelry",
    "Kitchen" => "Kitchen",
    "Lawn & Patio" => "HomeGarden",
    "Loose Diamonds" => "Jewelry",
    "Magazine" => "Magazines",
    "Movie" => "UnboxVideo",
    "Music" => "Music",
    "Musical Instruments" => "MusicalInstruments",
    "Office Product" => "OfficeProducts",
    "Personal Computer" => "PCHardware",
    "Pet Products" => "PetSupplies",
    "Photography" => "Photo",
    "Shoes" => "Shoes",
    "Single Detail Page Misc" => "All",
    "Software" => "Software",
    "Sports" => "SportingGoods",
    "Toy" => "Toys",
    "TV Series Episode Video on Demand" => "UnboxVideo",
    "TV Series Video on Demand" => "UnboxVideo",
    "Video" => "DVD",
    "Video Games" => "VideoGames",
    "Watch" => "Jewelry",
    "Wireless" => "Wireless",
  );
  $SearchIndex = $map[$ProductGroup];
  if (!empty($SearchIndex)) {
    return $SearchIndex;
  }
  return "All";

}

/**
 * Update the query parameters based on passed-in parameters.
 *
 * @param $newstuff
 *   Associative Array of Amazon parameters in URL to be changed
 *
 * @return new array of query params
 */
function _amazon_store_revise_query_parameters($updated_params = array()) {
  $newget = $_GET;
  unset($newget['page'], $newget['q']); // If we're rewriting the query, the page is not going to be relevant
  if (empty($_GET['SearchIndex'])) {
    $newget['SearchIndex'] = variable_get('amazon_store_default_search_index', 'All');
  }
  foreach ($updated_params as $key => $value) {
    $newget[$key] = $value;
  }
  return $newget;
}

/**
 * Create a directed graph (tree) of all the possible variations
 * For example, for a pants entry with size,color, it might have
 * 	30x29
 *     -> gray
 * 			-> asin1
 * 			-> asin2
 * 		-> red
 * 			-> asin3
 *  30x30
 * 		-> gray
 * 			-> asin4
 * 		-> green
 * 			-> asin5
 *
 * @param $item
 * 		Amazon Product, in simplexml object
 * @return
 * 		Array representing all possible attribute paths
 */
function _amazon_store_process_variations($item) {
  static $savedItem;
  static $itemsByAttribute = array();
  if ($savedItem == (string) $item->ASIN && !empty($itemsByAttribute)) {
    return $itemsByAttribute;
  }
  $savedItem = (string) $item->ASIN;
  $itemsByAttribute = array();

  $dimensions = _amazon_store_get_variation_dimensions($item);
  if (!empty($item->Variations) && !empty($item->Variations->Item)) {
    // Iterate the listed dimensions for the product
    // In each dimension, iterate through the Items (sub-asins) listed in this parent asin
    foreach ($item->Variations->Item as $variation) {
      // For each sub-asin, record the values of its dimensions
      $curPtr = & $itemsByAttribute;
      foreach ($dimensions as $otherDimension) {
        $attr = (string) $variation->ItemAttributes->$otherDimension;
        if (empty($curPtr[$attr])) {
          $curPtr[$attr] = array();
        }
        $curPtr = & $curPtr[$attr];
      }
      _amazon_store_iterate_offers($variation->Offers, $variation, $curPtr);
    }
  }
  else { // We didn't have variations, so just do the offers
    $curPtr = & $itemsByAttribute;

    _amazon_store_iterate_offers($item->Offers, $item, $curPtr);
  }
  return $itemsByAttribute;
}

/**
 * Populate offers into the passed-in variations structure
 *
 * @param unknown_type $offers
 * @param unknown_type $itemPtr
 * @param unknown_type $curPtr
 */
function _amazon_store_iterate_offers($offers, $itemPtr, &$curPtr) {
  // Return if we have no offers
  if (!is_object($offers) || count((array) $offers->Offer) < 1) {
    return;
  }
  foreach ($offers->Offer as $offer) {
    $asin = (string) $itemPtr->ASIN;
    $offerListingId = (string) $offer->OfferListing->OfferListingId;
    $curPtr[$asin][$offerListingId]['availability'] = (string) $offer->OfferListing->Availability;
    $curPtr[$asin][$offerListingId]['price'] = (string) $offer->OfferListing->Price->FormattedPrice;
    if (!empty($offer->OfferListing->SalePrice)) {
      $curPtr[$asin][$offerListingId]['price'] = (string) $offer->OfferListing->SalePrice->FormattedPrice;
    }
    if (!empty($offer->Merchant)) {
      $curPtr[$asin][$offerListingId]['merchantname'] = (string) $offer->Merchant->Name;

    }
    else {
      $curPtr[$asin][$offerListingId]['merchantname'] = (string) $offer->Seller->Nickname;

    }

    // Now for some debugging info
    if (AS_DEBUG) {
      if ((string) $offer->Merchant->MerchantId == "ATVPDKIKX0DER") {
        $GLOBALS['amazon_offers'][(string) $itemPtr->ItemAttributes->ClothingSize][(string) $itemPtr->ItemAttributes->Color]['offer'][] = $offerListingId;
        $GLOBALS['amazon_offers'][(string) $itemPtr->ItemAttributes->ClothingSize][(string) $itemPtr->ItemAttributes->Color]['ptr'][] = $offer;
      }
    }
  }
}

/**
 * Return an array of dimensions (such as ClothingSize, Color)
 * based on metadata in the amazon item
 *
 * @param unknown_type $item
 * 	Amazon product information as SimpleXML object
 * @return
 * 	Simple array of dimension names
 */
function _amazon_store_get_variation_dimensions($item) {
  $dimensions = array();
  if (!empty($item->Variations->VariationDimensions)) {
    foreach ($item->Variations->VariationDimensions->VariationDimension as $dimension) {
      $dimensions[] = (string) $dimension;
    }
  }
  return $dimensions;
}

/**
 * Form to "add to cart". Normally embedded in page either of search results
 * or on item display page
 *
 * Most form elements and the form itself are identified with the ASIN
 * attached to their name. This is a result of Drupal's failure to handle
 * multiple forms on a page, especially with AJAX.  @TODO: This should be
 * fixed now!
 *
 * The various parts of the form are all driven by AJAX, so no page refresh
 * is required to add to cart or to change the size/color or whatever permutations
 *
 * @param $form
 * @param  $form_state
 * @param  $asin
 *   The ASIN identifying the item we're working with
 * @param  $context  string
 *   Pretty hacky. This allows a hook_form_alter to behave differently based
 *   on how the form was constructed. All it does here is add the "context"
 *   string as a hidden element in the form so it can be used later.
 * @return prepared form
 */
function amazon_store_addcart_form($form, &$form_state, $asin, $context = 'normal') {
  $moduledir = drupal_get_path('module', 'amazon_store');
  $form['#attached']['css'] = array("$moduledir/amazon_store.css");
  $form['#attached']['js'] = array("$moduledir/amazon_store.js");

  // We either have asin passed in, or get it from values array
  if (empty($asin)) {
    $asin = $form_state['values']['fields']['asin'];
  }

  if (AS_DEBUG) {
    $load_path = $asin . ": ";
  }

  $item = amazon_store_retrieve_item($asin);
  if (empty($item)) {
    return;
  }
  $itemsByAttribute =  _amazon_store_process_variations($item);
  $nextSelect = & $itemsByAttribute;
  $dimensions = _amazon_store_get_variation_dimensions($item);
  $formwrapper = "addcart-form-$asin";

  $form['#prefix'] = "<div id='$formwrapper' class='form-wrapper'>";
  $form['#suffix'] = '</div>';
  $form['#tree'] = TRUE;

  // These are required because the form_id is no longer just the plain one, but
  // has ASIN attached to it (many forms driven by one handler)
  $form['#validate'][] = 'amazon_store_addcart_form_validate';
  $form['#submit'][] = 'amazon_store_addcart_form_submit';
  $form['item_title'] = array(
      '#type' => 'value',
      '#value' => (string) $item->ItemAttributes->Title,
  );
  $fieldswrapper = "fields-$asin-wrapper";

  $form['fields'] = array(
      '#prefix' => "<div id='$fieldswrapper' class='fields-wrapper'>",
      '#suffix' => "</div>",
      '#type' => 'fieldset',
  );

  $form['fields']['asin'] = array(
      '#type' => 'value',
      '#value' => $asin,
  );

  // Hidden; used to inform hook_form_alter about how form was constructed.
  $form['fields']['context'] = array(
      '#type' => 'value',
      '#value' => $context,
  );

  if (!empty($item->Variations)) {

    // for each dimension, create a widget
    $nextSelect = & $itemsByAttribute;
    foreach ($dimensions as $dimension) {

      $form['fields'][$dimension . "-$asin"] = array(
        '#title' => $dimension,
        '#type' => 'select',
        '#ajax' => array(
          'callback' => '_amazon_store_addcart_callback',
          'wrapper' => "$formwrapper"
        ),
      );
      if (AS_DEBUG) {
        $form['fields'][$dimension]['#title'] .= " $asin";
      }

      // Generate a select with the legal values for this dimension, given the previous one
      if (!empty($nextSelect)) {
        // $selects = array("Select {$dimension}...");
        $selects = array();
        $possible_keys = array_keys($nextSelect);
        if (AS_DEBUG) {
          $possible_keys[] = "WIDENED $dimension " . date("His");
        }
        // Process the selects here with a debug addition to the value
        $selects += array_combine($possible_keys, $possible_keys);
        $curValue = !empty($form_state['values']['fields'][$dimension . "-$asin"]) ?
          $form_state['values']['fields'][$dimension . "-$asin"] : NULL;
        // If our current value is not in our array of possible values,
        // replace it with the first value of the possible
        if (empty($nextSelect[$curValue])) {
          $curValue = key($nextSelect);
        }
        $form['fields'][$dimension . "-$asin"]['#default_value'] = $curValue;
        if (AS_DEBUG) {
          $load_path .= $curValue . ": ";
        }

        $nextSelect = & $nextSelect[$curValue];
      }
      else { // NextSelect was empty
        $selects = array(t('Make other selections first'));
      }
      $form['fields'][$dimension . "-$asin"]['#options'] = $selects;
    }
  }

  // Now for the offers pulldown
  $selects = array();
  if (!empty($nextSelect)) {
    $key = key($nextSelect);
    $possible_keys = array_keys($nextSelect[$key]);
    foreach ($possible_keys as $offer) {
      $selects[$offer] = "{$nextSelect[$key][$offer]['merchantname']} - {$nextSelect[$key][$offer]['price']}";
    }
    if (AS_DEBUG) {
      $selects += array("WIDENED $dimension " . date("His"));
    }

  }
  else { // No offers yet due to missing selections
    $selects = array(t('Make other selections first'));
  }
  $form['fields']['offer' . "-$asin"] = array(
    '#title' => t('Merchant'),
    '#type' => 'select',
    '#options' => $selects,
    '#ajax' => array(
      'callback' => '_amazon_store_addcart_callback',
      'wrapper' => "$formwrapper"
    ),
  );
  $curValue = empty($form_state['values']['fields']['offer' . "-$asin"]) ? NULL : $form_state['values']['fields']['offer' . "-$asin"];

  // If the previously-set value is not in selects, we'll abandon it
  if (empty($selects[$curValue])) {
    $curValue = key($selects); // Just set to the first entry
  }
  if (AS_DEBUG) {
    $num_offers = count($nextSelect[$key]);
    $load_path .= $curValue . ": sub-asin={$key} ($num_offers offers), merchant={$nextSelect[$key][$curValue]['merchantname']}";
  }

  $form['fields']['offer' . "-$asin"]['#default_value'] = $curValue;
  $form['submits']['#type'] = 'fieldset';
  $form['submits']['offer-info' . "-$asin"] = array(
    '#type' => 'markup',
    '#prefix' => '<div class="offer-info-div">',
    '#suffix' => '</div>',
    '#markup' => "<span class='offer-status'><span class='sold-by'>" . t('Sold by') . " <span class='merchantname'>{$nextSelect[$key][$curValue]['merchantname']}</span></span>:
  <span class='availability'>{$nextSelect[$key][$curValue]['availability']}</span></span>",
  );

  $form['submits']['submit' . "-$asin"] = array(
    '#type' => 'submit',
    '#value' => t('Add to cart'),
    '#ajax' => array(
      'callback' => '_amazon_store_addcart_callback',
      'wrapper' => "$formwrapper"
    ),
  );


  if (strlen(key($form['fields']['offer' . "-$asin"]['#options'])) > 1) {
    $form['submits']['submit' . "-$asin"]['#value'] = t('Add to cart');
  }

  if ($item->ItemAttributes->Binding == 'Kindle Edition') {
    $form['submits']['submit' . "-$asin"]['#disabled'] = TRUE;
    $form['submits']['submit' . "-$asin"]['#value'] = t('Kindle Edition: Not available to purchase');
  }

  $form['info-update'] = array(
      '#value' => "<div id='info-$asin'></div>",
      '#suffix' => AS_DEBUG ? "load_path=$load_path" : "",
  );

  return $form;
}

/**
 * Validate the form by making sure that each widget has values that
 * relate to the parent widget. For example, the color green may be offered
 * in size M, but not in size S. So we have to make sure that the colors that
 * actually are in size M are in the widget.  Rebuild the form if necessary
 * by exiting with $form_state['rebuld'] = true.
 *
 * @param unknown_type $form
 * @param unknown_type $form_state
 */
function amazon_store_addcart_form_validate($form, &$form_state) {
  $asin = $form_state['values']['fields']['asin'];
  $item = amazon_store_retrieve_item($asin);
  if (empty($item)) {
    form_error($form['asin'], t('Sorry, An error occurred accessing this item. It may no longer be available from Amazon.'));
  }
  $itemsByAttribute =  _amazon_store_process_variations($item);
  $dimensions = _amazon_store_get_variation_dimensions($item);
  $nextSelect = $itemsByAttribute;

  foreach ($dimensions as $dimension) {
    $thisValue = $form_state['values']['fields'][$dimension . "-$asin"];
    $possibleSelections = array_keys($nextSelect);
    if (!empty($thisValue) && !empty($nextSelect[$thisValue])) {
      $nextSelect = & $nextSelect[$thisValue];
      continue; // We found a valid entry for this dimension
    }
    else { // There is no path forward from here, so the selections have changed and we'll rebuild
      $form_state['rebuild'] = TRUE;
      drupal_set_message(t('Please make a selection for %dimension', array('%dimension' => $dimension)));
      return;
    }
  }
  if (empty($form_state['values']['fields']['offer' . "-$asin"])) { // We don't have an offer selected yet
    form_set_error("fields[offer-$asin]", ('Please choose a merchant'));
    $form_state['rebuild'] = TRUE;
    return;
  }
  else { // We do have an offer, but need to check it for validity
    $thisValue = $form_state['values']['fields']['offer' . "-$asin"];
    if (!empty($nextSelect[key($nextSelect)][$thisValue])) {
      // The offer is good. validation complete.
      $form_state['rebuild'] = FALSE;
      return;
    }
  }
  // All other cases we have to rebuild the form and get a valid combination
  $form_state['rebuild'] = TRUE;
  return;
}

/**
 * Submit function - do the add-to-cart
 *
 * @param unknown_type $form
 * @param unknown_type $form_state
 */
function amazon_store_addcart_form_submit($form, &$form_state) {
  $asin = $form_state['values']['fields']['asin'];
  $offer = $form_state['values']['fields']["offer-$asin"];

  $result = _amazon_store_add_to_cart(NULL, $offer);
  if ($result) {
    $directory = drupal_get_path('module', 'amazon_store');
    drupal_set_message(t('%item was added to your cart. <br/><em>!link</em>', array('%item' => $form['item_title']['#value'], '!link' => l(t("View Cart"), AMAZON_STORE_PATH . '/cart'))));
  }
  else {
    drupal_set_message(t('Error: Item not added to cart'));
  }
  $params = _amazon_store_revise_query_parameters();
  $form_state['redirect'] = array('amazon_store', array('query' => $params));
}

/**
 * AJAX callback handler for the add-to-cart update.
 *
 * This one handles the replacement of the select
 * widgets only, not the submission.
 *
 */
function _amazon_store_addcart_callback($form, &$form_state) {
  $commands[] = ajax_command_replace(NULL, drupal_render($form));
  $commands[] = ajax_command_append(NULL, theme('status_messages'));

  return array('#type' => 'ajax', '#commands' => $commands);
}


/**
 * Return the SearchIndex as entered in the URL of this page
 *
 * @return
 * 	Currently-selected search index
 */
function _amazon_store_get_search_index() {
  return empty($_GET['SearchIndex']) ? "All" : $_GET['SearchIndex'];
  return $searchIndex;
}

/**
 * Return the SortOrder as in the URL of this page,
 * or NULL if none.
 *
 * @return unknown
 */
function _amazon_store_get_sort() {
  $sort = NULL;
  if (!empty($_GET['Sort'])) {
    $sort = $_GET['Sort'];
  }
  return $sort;
}


/**
 * Change sort order for search results page
 *
 * @param unknown_type $form_state
 * @return
 * 	Form for changing sort order
 */
function amazon_store_sort_form($form, &$form_state) {

  $form['#tree'] = TRUE;
  $moduledir = drupal_get_path('module', 'amazon_store');
  $form['#attached']['css'] = array("$moduledir/amazon_store.css");
  $form['#attached']['js'] = array("$moduledir/amazon_store.js");

  $searchIndex = _amazon_store_get_search_index();
  if ($searchIndex == "All") {
    return NULL; // No sorting for "All"
  }
  $options = $GLOBALS['amazon_store_search_indexes']->getSortPossiblities($searchIndex);

  $form['sortby'] = array(
    '#title' => t('Sort Results By'),
    '#type' => 'select',
    '#options' => $options,
    '#attributes' => array('class' => array('amazon-store-autosubmit')),
    '#default_value' =>  _amazon_store_get_sort(),
    // '#attributes' => array('onchange' => 'dest=this.options[this.options.selectedIndex].value; window.location = dest;'),
  );
  $form['sortby-submit'] = array(
    '#type' => 'submit',
    '#value' => t('Sort'),
    '#name' => t('Sort'),
    '#attributes' => array('class' => array('amazon-store-no-js')),
  );
  $form['clear'] = array(
    '#type' => 'markup',
    '#markup' => "<div class='search-form-clear'></div>",
  );
  return $form;
}

function amazon_store_sort_form_submit($form, &$form_state) {
  $new_params = _amazon_store_revise_query_parameters(array('Sort' => $form_state['values']['sortby']));
  $form_state['redirect'] = array(AMAZON_STORE_PATH, array('query' => $new_params));
}

/**
 * SearchBinSets selector form, for search results page
 *
 * @param  $form_state
 * @param  $searchBinSets SimpleXML object from search results
 * @return
 * 	a form
 */
function amazon_store_searchbin_sets_form($form, &$form_state, $searchBinSets) {
  $form = array(
    '#tree' => TRUE,
    '#title' => t('Narrow your search'),
  );
  $moduledir = drupal_get_path('module', 'amazon_store');
  $form['#attached']['css'] = array("$moduledir/amazon_store.css");
  $form['#attached']['js'] = array("$moduledir/amazon_store.js");

  $form['searchbins'] = array(
    '#type' => 'fieldset',
    '#title' => t('Narrow your search'),
  );

  // For each search bin set, create a select control and a submit button
  foreach ($searchBinSets->SearchBinSet as $binset) {
    $narrowBy = (string) $binset->attributes()->NarrowBy;

    $form['searchbins'][$narrowBy]['select'] = array(
      '#type' => 'select',
      '#attributes' => array('class' => array('amazon-store-autosubmit')),
      '#options' => array('' => t('Narrow by') . ' ' . $narrowBy),
    );
    $form['searchbins'][$narrowBy]['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Narrow by') . $narrowBy,
      '#name' => $narrowBy,
      '#submit' => array('amazon_store_searchbin_sets_form_submit'),
      '#attributes' => array('class' => array('amazon-store-no-js')),
    );

    // For each "bin", which is like a price category or brand,
    // Add an option to the select control.
    // The option key is constructed as 'key=value;key2=value2;key3=value3';
    // In the case of the price ranges it can have more than one key.
    foreach ($binset->Bin as $bin) {
      $parameter_string = "";
      foreach ($bin->BinParameter as $parameter) {
        $parameter_string .= $parameter->Name . '=' . (string)$parameter->Value . ';';
      }
      $form['searchbins'][$narrowBy]['select']['#options'][$parameter_string] = (string)$bin->BinName;
    }
  }
  $form['clear'] = array(
    '#type' => 'markup',
    '#markup' => "<div class='search-form-clear'></div>",
  );

  return $form;
}

/**
 * Submit the searchbinsets_form.
 *
 * This actually just redirects to a URL that describes the search.
 */
function amazon_store_searchbin_sets_form_submit($form, &$form_state) {
  foreach(element_children($form['searchbins']) as $child) {
    // Break up our key, which is in the form 'key1=value1;key2=value2;'.
    if (!empty($form_state['values']['searchbins'][$child]['select'])) {
      $new_strings = explode(';', $form_state['values']['searchbins'][$child]['select']);
      foreach ($new_strings as $string) {
        if (empty($string)) {
          continue;
        }
        $additions = explode('=', $string);
        $changes[$additions[0]] = $additions[1];
      }
    }
  }
  $new_params = _amazon_store_revise_query_parameters($changes);
  $form_state['redirect'] = array('amazon_store', array('query' => $new_params));
}

/**
 * Small form used to set item quantity for the Shopping Cart page.
 * Each element and the form itself have their names keyed to the ASIN,
 * since Drupal can't handle multiple forms of the same type on a page,
 * especially with AJAX
 *
 * @param $form_state
 * @param $cart_entry
 * @param $item_number
 */
function _amazon_store_cart_quantity_form($form, &$form_state, $cart_entry, $item_number) {
  $moduledir = drupal_get_path('module', 'amazon_store');
  $form['#attached']['css'] = array("$moduledir/amazon_store.css");
  $form['#attached']['js'] = array("$moduledir/amazon_store.js");


  $asin = (string) $cart_entry->ASIN;
  $formwrapper = "addcart-form-$asin";
  $form['#prefix'] = "<div id='$formwrapper' class='form-wrapper'>";
  $form['#suffix'] = '</div>';
  $form['#tree'] = TRUE;

  // These are required because the form_id is no longer just the plain one.
  $form['#submit'][] = '_amazon_store_cart_quantity_form_submit';
  $form['#validate'][] = '_amazon_store_cart_quantity_validate';
  $form['asin'] = array(
    '#type' => 'value',
    '#value' => $asin,
  );
  $form['cartitemid' . "-$asin"] = array(
    '#type' => 'value',
    '#value' => (string) $cart_entry->CartItemId,
  );

  // This item is the nth item in the cart.
  $form['item_number' . "-$asin"] = array(
    '#type' => 'value',
    '#value' => $item_number,
  );

  $form['quantity' . "-$asin"] = array(
    '#type' => 'textfield',
    '#title' => t('Quantity'),
    '#default_value' => $cart_entry->Quantity,
    '#size' => 2,
  );

  $form['submit' . "-$asin"] = array(
    '#type' => 'submit',
    '#value' => t('Update Quantity'),
  );

  return $form;
}

function _amazon_store_cart_quantity_validate($form, &$form_state) {
  $asin = $form_state['values']['asin'];
  $quantity = $form_state['values']['quantity' . "-$asin"];
  if (!is_numeric($quantity) || $quantity < 0 ) {
    form_set_error('quantity' . "-$asin", "Quantity must be a number equal to or greater than zero");
  }
}

function _amazon_store_cart_quantity_form_submit($form, &$form_state) {
  $asin = $form_state['values']['asin'];
  amazon_store_update_cart_quantity($form_state['values']['cartitemid' . "-$asin"], $form_state['values']['quantity' . "-$asin"]);
  // And return to this same page
}

/**
 * Turn a link or path into a form button.
 * This is only intended to handle internal paths and simple links like
 * the one to the amazon checkout.
 * @param $form
 * @param $form_state
 * @param $name
 *   button name.
 * @param $link
 *   URL we'll link to.
 * @return form.
 */
function amazon_store_buttonize_link($form, &$form_state, $name, $link) {
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => $name,
  );
  $form_state['storage']['linkbutton_link'] = $link;
  $form_state['redirect'] = $link;
  return $form;
}

function amazon_store_buttonize_link_submit($form, &$form_state) {
  $form_state['redirect'] = $form_state['storage']['linkbutton_link'];
}
/**
 * Determine if a given parameter is allowed for given SearchIndex.
 *
 * @param $SearchIndex
 *   The SearchIndex to test. Example: Apparel or Books
 * @param $parameter_name
 *   Parameter like 'Author' or  'Manufacturer'
 */
function amazon_store_allowed_parameter($SearchIndex, $parameter_name) {
  global $amazon_store_search_indexes;
  $parametersAllowed = $amazon_store_search_indexes->getParametersAllowed();
  return in_array($parameter_name, $parametersAllowed[$SearchIndex]);
}



/**
 * Compute pager options and invoke theme pager.
 *
 * @param int $searchResults
 *   The actual Amazon search results, as simpleXML object.
 * @param int $pager_element
 *   An optional integer to distinguish between multiple pagers on one page.
 *
 * @return string
 *   The pager as HTML.
 */
function amazon_store_search_results_pager($searchResults, $pager_element = 0) {
  global $pager_page_array, $pager_total_items, $pager_total;

  $pager_page_array = array(0);
  if (!empty($_GET['page'])) {
    $pager_page_array = explode(',', $_GET['page']);
  }
  $results_per_page = 10; // Amazon standard
  $total_results = $searchResults->TotalResults;
  $pager_total_items[$pager_element] = $total_results;
  $pager_total[$pager_element] = ceil($total_results / $results_per_page);
  $pager_page_array[$pager_element] = max(0, min((int)$pager_page_array[$pager_element], ((int)$pager_total[$pager_element]) - 1));

  // 10 items per page is wired in from Amazon API.
  return theme('pager', array('tags' => array(), 'element' => $pager_element));
}


/**
 * Theme a link into a button using the current theme's button definition.
 * @param $variables
 */
function theme_amazon_store_link_button($variables) {
  $hash = drupal_hash_base64($variables['url']);
  $form = drupal_get_form("amazon_store_buttonize_link_" . $hash, $variables['text'], $variables['url']);
  $markup = drupal_render($form);
  return $markup;
}


/**
 * Helper functions for amazon_store_details_panel.php.
 */
function amazon_store_manufacturer_format($attributeType, $attributeValue) {
  return theme('amazon_store_search_results_manufacturer', array('manufacturer' => (string)$attributeValue));
}

/**
 * Format a participant detail.
 *
 * This works for author, artist, composer. It guesses the SearchIndex from
 * the ProductGroup. There may be more than one author, so it returns an
 * unordered list in that case.
 *
 * @param $attributeType
 *   'Author' or 'Composer', etc.
 * @param $attributeValue
 *   An array of author/composer/artist names
 * @param $allAttributes
 *   The Attributes section from the original XML.
 */
function amazon_store_participant_format($attributeType, $attributeValue, $allAttributes) {
  $search_index = ProductGroup2SearchIndex((string)$allAttributes->ProductGroup);
  $output = "";
  $multi = FALSE;
  if (count($attributeValue) > 1) {
    $multi = TRUE;
  }

  foreach ($attributeValue as $value) {
    $link = l((string)$value, AMAZON_STORE_PATH, array('attributes' => array('rel' => 'nofollow'), 'query'=> array((string)$attributeType => (string)$value, 'SearchIndex' => $search_index)));
    if ($multi) {
      $link = "<li>$link</li>";
    }
    $output .= $link;
  }
  if ($multi) {
    $output = '<ul>' . $output . '</ul>';
  }
  return $output;
}

function amazon_store_feature_format($attributeType, $attributeValue, $allAttributes) {
  $output = "<ul>";
  foreach ($attributeValue as $feature) {
    // Strip items that contain links, which will be unuseful.
    if (!preg_match("/href=/i", $feature)) {
      $output .= "<li>" . check_plain($feature) . "</li>";
    }
  }
  $output .= "</ul>";
  return $output;
}


function amazon_store_binding_format($attributeType, $attributeValue, $allAttributes) {
  $output = (string)$attributeValue;
  if (!empty($allAttributes->NumberOfPages)) {
    $output .= ", {$allAttributes->NumberOfPages} pages";
  }
  return $output;
}

function amazon_store_dimensions_format($attributeType, $attributeValue, $allAttributes) {
  $output = "<ul>";
  if ($attributeValue->Height) {
    $output .= "<li>Dimensions: {$attributeValue->Length}L x {$attributeValue->Width}W x {$attributeValue->Height}H</li>";
  }
  if ($attributeValue->Weight) {
    $output .= "<li>Weight: $attributeValue->Weight</li>";
  }
  $output .= "</ul>";
  return $output;
}

/**
 * Format an attribute based on various handlers.
 *
 * @param $attribute_value
 * @param $handler
 * @param $allAttributes
 */
function amazon_store_format_attribute($attributeType, $attribute_value, $handler, $allAttributes) {
  $output = "{$handler['name']}: ";
  if (!empty($handler['outputElement'])) {
    $output .= $attribute_value->{$handler['outputElement']};
  }
  elseif (!empty($handler['handler'])) {
    $output .= $handler['handler']($attributeType, $attribute_value, $allAttributes);
  }
  else {
    $output .= (string)$attribute_value;
  }
  return $output;
}

/**
 * Return the store path when other modules need to know it.
 */
function amazon_store_get_amazon_store_path() {
  return AMAZON_STORE_PATH;
}
